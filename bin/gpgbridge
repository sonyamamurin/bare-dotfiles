#!/usr/bin/env bash
#--------------------------------------------------------------------------
# GPG bridging from WSL gpg to gpg4win gpg-agent.exe
# (needed to use a Yubikey, since WSL cannot access USB devices)

# Set this to true if running WSL1

WSL2=false

SCRIPT_DIR_WSL='/mnt/c/tools/'
# shellcheck disable=SC1003
SCRIPT_DIR_WIN='C:\\Program1\\'

PIDFILE_WSL="$HOME/.gpgbridge.pid"
LOGFILE_WSL="$HOME/.gpgbridge.log"

PIDFILE_WIN="${SCRIPT_DIR_WIN}gpgbridge.pid"
LOGFILE_WIN="${SCRIPT_DIR_WIN}gpgbridge.log"

SCRIPT_FILE_NAME='gpgbridge.rb'

SCRIPT_PATH_WSL="${SCRIPT_DIR_WSL}${SCRIPT_FILE_NAME}"

# Set to true to redirect output to /dev/null
QUIET=false

function start_gpgbridge
{
    if ! command -v ruby.exe >/dev/null
    then
        echo 'No ruby.exe found in path'
        return
    fi

    local cmd=( \
        'ruby' \
        "$SCRIPT_PATH_WSL" \
        '--verbose' \
        '--daemon' \
        "--pidfile $PIDFILE_WSL" \
        "--logfile $LOGFILE_WSL" \
        "--windows-pidfile $PIDFILE_WIN" \
        "--windows-logfile $LOGFILE_WIN" \
    )

    if [ "$1" = 'ssh' ]
    then
        cmd+=('--enable-ssh-support')
        SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
        export SSH_AUTH_SOCK
    fi

    if [ "$WSL2" = true ]
    then
        cmd+=("--remote-address $(ip route | awk '/^default via / {print $3}')")
    fi

    if [ "$QUIET" = true ]
    then
        cmd+=('>/dev/null 2>&1')
    fi

    printf -v _cmd '%s ' "${cmd[@]}"

    eval "$_cmd"
}

function stop_gpgbridge
{
    pkill -TERM -f 'ruby.*gpgbridge\.rb'
}

function restart_gpgbridge
{
    stop_gpgbridge
    sleep 1
    start_gpgbridge "$@"
}

if [ -f "$SCRIPT_PATH_WSL" ]
then
    start_gpgbridge ssh
fi
